// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: automotive_ai/heart/heart_service.proto

#include "automotive_ai/heart/heart_service.pb.h"
#include "automotive_ai/heart/heart_service.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace automotive_ai {
namespace heart {

static const char* Heart_method_names[] = {
  "/automotive_ai.heart.Heart/Report",
  "/automotive_ai.heart.Heart/Init",
  "/automotive_ai.heart.Heart/Serve",
  "/automotive_ai.heart.Heart/Connect",
  "/automotive_ai.heart.Heart/Start",
  "/automotive_ai.heart.Heart/Step",
  "/automotive_ai.heart.Heart/Stop",
};

std::unique_ptr< Heart::Stub> Heart::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Heart::Stub> stub(new Heart::Stub(channel));
  return stub;
}

Heart::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_Report_(Heart_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Init_(Heart_method_names[1], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Serve_(Heart_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Connect_(Heart_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Start_(Heart_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Step_(Heart_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Stop_(Heart_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Heart::Stub::Report(::grpc::ClientContext* context, const ::automotive_ai::heart::ReportReq& request, ::automotive_ai::heart::ReportRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Report_, context, request, response);
}

void Heart::Stub::experimental_async::Report(::grpc::ClientContext* context, const ::automotive_ai::heart::ReportReq* request, ::automotive_ai::heart::ReportRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Report_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Report(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ReportRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Report_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Report(::grpc::ClientContext* context, const ::automotive_ai::heart::ReportReq* request, ::automotive_ai::heart::ReportRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Report_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Report(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ReportRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Report_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ReportRes>* Heart::Stub::AsyncReportRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ReportReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ReportRes>::Create(channel_.get(), cq, rpcmethod_Report_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ReportRes>* Heart::Stub::PrepareAsyncReportRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ReportReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ReportRes>::Create(channel_.get(), cq, rpcmethod_Report_, context, request, false);
}

::grpc::Status Heart::Stub::Init(::grpc::ClientContext* context, const ::automotive_ai::heart::InitReq& request, ::automotive_ai::heart::InitRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Init_, context, request, response);
}

void Heart::Stub::experimental_async::Init(::grpc::ClientContext* context, const ::automotive_ai::heart::InitReq* request, ::automotive_ai::heart::InitRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Init_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::InitRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Init_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Init(::grpc::ClientContext* context, const ::automotive_ai::heart::InitReq* request, ::automotive_ai::heart::InitRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Init_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Init(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::InitRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Init_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::InitRes>* Heart::Stub::AsyncInitRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::InitReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::InitRes>::Create(channel_.get(), cq, rpcmethod_Init_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::InitRes>* Heart::Stub::PrepareAsyncInitRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::InitReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::InitRes>::Create(channel_.get(), cq, rpcmethod_Init_, context, request, false);
}

::grpc::Status Heart::Stub::Serve(::grpc::ClientContext* context, const ::automotive_ai::heart::ServeReq& request, ::automotive_ai::heart::ServeRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Serve_, context, request, response);
}

void Heart::Stub::experimental_async::Serve(::grpc::ClientContext* context, const ::automotive_ai::heart::ServeReq* request, ::automotive_ai::heart::ServeRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Serve_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Serve(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ServeRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Serve_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Serve(::grpc::ClientContext* context, const ::automotive_ai::heart::ServeReq* request, ::automotive_ai::heart::ServeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Serve_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Serve(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ServeRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Serve_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ServeRes>* Heart::Stub::AsyncServeRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ServeReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ServeRes>::Create(channel_.get(), cq, rpcmethod_Serve_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ServeRes>* Heart::Stub::PrepareAsyncServeRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ServeReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ServeRes>::Create(channel_.get(), cq, rpcmethod_Serve_, context, request, false);
}

::grpc::Status Heart::Stub::Connect(::grpc::ClientContext* context, const ::automotive_ai::heart::ConnectReq& request, ::automotive_ai::heart::ConnectRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Connect_, context, request, response);
}

void Heart::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::automotive_ai::heart::ConnectReq* request, ::automotive_ai::heart::ConnectRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ConnectRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::automotive_ai::heart::ConnectReq* request, ::automotive_ai::heart::ConnectRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Connect(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::ConnectRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Connect_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ConnectRes>* Heart::Stub::AsyncConnectRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ConnectReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ConnectRes>::Create(channel_.get(), cq, rpcmethod_Connect_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::ConnectRes>* Heart::Stub::PrepareAsyncConnectRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::ConnectReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::ConnectRes>::Create(channel_.get(), cq, rpcmethod_Connect_, context, request, false);
}

::grpc::Status Heart::Stub::Start(::grpc::ClientContext* context, const ::automotive_ai::heart::StartReq& request, ::automotive_ai::heart::StartRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Start_, context, request, response);
}

void Heart::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::automotive_ai::heart::StartReq* request, ::automotive_ai::heart::StartRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StartRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::automotive_ai::heart::StartReq* request, ::automotive_ai::heart::StartRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Start(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StartRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Start_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StartRes>* Heart::Stub::AsyncStartRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StartReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StartRes>::Create(channel_.get(), cq, rpcmethod_Start_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StartRes>* Heart::Stub::PrepareAsyncStartRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StartReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StartRes>::Create(channel_.get(), cq, rpcmethod_Start_, context, request, false);
}

::grpc::Status Heart::Stub::Step(::grpc::ClientContext* context, const ::automotive_ai::heart::StepReq& request, ::automotive_ai::heart::StepRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Step_, context, request, response);
}

void Heart::Stub::experimental_async::Step(::grpc::ClientContext* context, const ::automotive_ai::heart::StepReq* request, ::automotive_ai::heart::StepRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Step_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Step(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StepRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Step_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Step(::grpc::ClientContext* context, const ::automotive_ai::heart::StepReq* request, ::automotive_ai::heart::StepRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Step_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Step(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StepRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Step_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StepRes>* Heart::Stub::AsyncStepRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StepReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StepRes>::Create(channel_.get(), cq, rpcmethod_Step_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StepRes>* Heart::Stub::PrepareAsyncStepRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StepReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StepRes>::Create(channel_.get(), cq, rpcmethod_Step_, context, request, false);
}

::grpc::Status Heart::Stub::Stop(::grpc::ClientContext* context, const ::automotive_ai::heart::StopReq& request, ::automotive_ai::heart::StopRes* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Stop_, context, request, response);
}

void Heart::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::automotive_ai::heart::StopReq* request, ::automotive_ai::heart::StopRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StopRes* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, std::move(f));
}

void Heart::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::automotive_ai::heart::StopReq* request, ::automotive_ai::heart::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, reactor);
}

void Heart::Stub::experimental_async::Stop(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::automotive_ai::heart::StopRes* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Stop_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StopRes>* Heart::Stub::AsyncStopRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StopReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StopRes>::Create(channel_.get(), cq, rpcmethod_Stop_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::automotive_ai::heart::StopRes>* Heart::Stub::PrepareAsyncStopRaw(::grpc::ClientContext* context, const ::automotive_ai::heart::StopReq& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::automotive_ai::heart::StopRes>::Create(channel_.get(), cq, rpcmethod_Stop_, context, request, false);
}

Heart::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::ReportReq, ::automotive_ai::heart::ReportRes>(
          std::mem_fn(&Heart::Service::Report), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[1],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::InitReq, ::automotive_ai::heart::InitRes>(
          std::mem_fn(&Heart::Service::Init), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::ServeReq, ::automotive_ai::heart::ServeRes>(
          std::mem_fn(&Heart::Service::Serve), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::ConnectReq, ::automotive_ai::heart::ConnectRes>(
          std::mem_fn(&Heart::Service::Connect), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::StartReq, ::automotive_ai::heart::StartRes>(
          std::mem_fn(&Heart::Service::Start), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::StepReq, ::automotive_ai::heart::StepRes>(
          std::mem_fn(&Heart::Service::Step), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Heart_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Heart::Service, ::automotive_ai::heart::StopReq, ::automotive_ai::heart::StopRes>(
          std::mem_fn(&Heart::Service::Stop), this)));
}

Heart::Service::~Service() {
}

::grpc::Status Heart::Service::Report(::grpc::ServerContext* context, const ::automotive_ai::heart::ReportReq* request, ::automotive_ai::heart::ReportRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Init(::grpc::ServerContext* context, const ::automotive_ai::heart::InitReq* request, ::automotive_ai::heart::InitRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Serve(::grpc::ServerContext* context, const ::automotive_ai::heart::ServeReq* request, ::automotive_ai::heart::ServeRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Connect(::grpc::ServerContext* context, const ::automotive_ai::heart::ConnectReq* request, ::automotive_ai::heart::ConnectRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Start(::grpc::ServerContext* context, const ::automotive_ai::heart::StartReq* request, ::automotive_ai::heart::StartRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Step(::grpc::ServerContext* context, const ::automotive_ai::heart::StepReq* request, ::automotive_ai::heart::StepRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Heart::Service::Stop(::grpc::ServerContext* context, const ::automotive_ai::heart::StopReq* request, ::automotive_ai::heart::StopRes* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace automotive_ai
}  // namespace heart

