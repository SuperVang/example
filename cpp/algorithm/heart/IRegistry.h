// Generated by the 'ai.aai.core/scripts/autogen/generate_cm.py' script.
// If you make any local change, they will be lost.

#pragma once

#include <string>
#include <memory>
#include <chrono>
#include <future>
#include <boost/optional.hpp>

#include <automotive_ai/world/new_traffic_service.grpc.pb.h>


namespace aai_heart {

//
// automotive_ai.world.NewTrafficService (automotive_ai/world/new_traffic_service.proto)
//

struct IServiceNewTraffic
{
    virtual ~IServiceNewTraffic() = default;

    virtual void OnGetTraffic(
        const ::google::protobuf::Empty& request,
        std::promise<::automotive_ai::common::NewTrafficVehicles> promise) = 0;

    virtual void OnReportTraffic(
        const ::automotive_ai::common::NewTrafficVehicles& request,
        std::promise<::google::protobuf::Empty> promise) = 0;

    virtual void OnStepNextEnd(
        const ::google::protobuf::Empty& request,
        std::promise<::google::protobuf::Empty> promise) = 0;
};

std::unique_ptr<IServiceNewTraffic> makeServiceNewTrafficFromGrpc(std::shared_ptr<::automotive_ai::world::NewTrafficService::Service> proxy);

struct IStubNewTraffic
{
    virtual ~IStubNewTraffic() = default;

    virtual ::automotive_ai::common::NewTrafficVehicles
        GetTraffic(
            const ::google::protobuf::Empty& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;

    virtual std::future<::automotive_ai::common::NewTrafficVehicles>
        GetTrafficAsync(
            const ::google::protobuf::Empty& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;

    virtual ::google::protobuf::Empty
        ReportTraffic(
            const ::automotive_ai::common::NewTrafficVehicles& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;

    virtual std::future<::google::protobuf::Empty>
        ReportTrafficAsync(
            const ::automotive_ai::common::NewTrafficVehicles& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;

    virtual ::google::protobuf::Empty
        StepNextEnd(
            const ::google::protobuf::Empty& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;

    virtual std::future<::google::protobuf::Empty>
        StepNextEndAsync(
            const ::google::protobuf::Empty& request,
            boost::optional<std::chrono::system_clock::time_point> deadline = boost::none) = 0;
};

std::unique_ptr<::automotive_ai::world::NewTrafficService::StubInterface> makeGrpcFromStubNewTraffic(std::shared_ptr<IStubNewTraffic> proxy);

//
// Registry
//

struct IRegistry
{
    virtual ~IRegistry() = default;

    // NewTraffic: automotive_ai.world.NewTrafficService (automotive_ai/world/new_traffic_service.proto)
    virtual void registerServiceNewTraffic(const std::string& name, std::shared_ptr<IServiceNewTraffic> service) = 0;
    virtual std::shared_ptr<IStubNewTraffic> registerStubNewTraffic(const std::string& name) = 0;

};

}
